<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>js模块</title>
  </head>
  <body>
    <h1>
      AMD----> requirejs ->>define(func) define([...],func) ->>
      require([module],callback(moduleX))
    </h1>
    <ul>
      <li>是RequireJS在推广过程中，对模块定义的规范</li>
      <li>
        异步定义-》requirejs可以异步加载模块，模块的加载不影响后面代码的执行
      </li>
      <li>
        推崇依赖前置-》 用到的依赖一开始写好
      </li>
    </ul>
    <h1>CMD----> seajs ->> defind(func) ->> seajs.use()</h1>
    <ul>
      <li>是SeaJS在推广过程中，对模块定义的规范</li>
      <li>
        推崇依赖就近-》 在什么地方使用到，就在什么地方require
      </li>
    </ul>
    <h1>CommonJS ----> module.exports exports.xx ->> require()</h1>
    <ul>
      <li>
        nodejs的模块系统，就是参照CommonJS规范实现
        -》js语言用于服务器端编程，一定要有模块，与操作系统和其它应用程序互动<br />
        注：<br />
        服务器端-》模块都放在本地硬盘，加载时间就是硬盘读取时间。加载时间不是问题，可以同步加载完成<br />
        浏览器-》
        模块都放在服务器端，加载时间取决于网速快慢，可能很久而‘假死’。不能采用'同步加载'，只能'异步加载'
        -》AMD诞生背景
      </li>
    </ul>
    <h1>ES6 Module ----> export ->> import</h1>
    <ul>
      <li>语言标准层面，实现的模块化功能。可以成为浏览器服务器通用解决方案</li>
      <li>编译时确定模块依赖关系</li>
      <li>import先于模块内其他语句执行</li>
    </ul>
    <h2>import()函数 -->动态异步加载</h2>
    <ul>
      <li></li>
    </ul>
    <h1>ES6 模块与 CommonJS 模块的差异</h1>
    <ul>
      <li>CommonJS模块输出的是一个值的拷贝，ES6模块输出的是一个值的引用</li>
      <li>
        CommonJS模块是运行时加载，ES6模块是编译时加载<br />
        CommonJS->整体加载，生成一个对象调用，运行时才能得到。没法在编译时优化<br />
        ES6->静态加载，定义对外接口引用，编译时就完成了，效率更高。还可以做类型检验优化
      </li>
    </ul>
  </body>
</html>
