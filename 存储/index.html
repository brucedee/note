<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
  </head>
  <body>
    <script>
      //cookie localStorage sessionStorage 不能跨域 不能跨浏览器 存储在客户端

      //-参与和服务器的通讯（随着http请求发送到服务器）
      //--cookie 参与，数据过多的话会带来性能问题
      //--localStorage sessionStorage 不参与

      //-生命周期
      //--cookie 可设置expires失效时间，未设置，则默认关闭浏览器后失效
      //--localStorage 除非手动清除，否则长期保留
      //--sessionStorage 关闭网页（或者浏览器）就会被清除

      //-作用域
      //--cookie 可设置path路径，未设置，则当前页面，兄弟页面，子页面
      //--localStorage 全局
      //--sessionStorage 仅在当前网页会话下有效(当前页面，或者链接跳转后的页面)

      //-存放数据大小
      //--cookie 4kb
      //--localStorage sessionStorage 5M

      //-易用性
      //--cookie 需要封装，原生api不友好
      //--localStorage sessionStorage 原生api可接受，亦可再封装

      //cookie session
      //cookie 客户端保存用户信息的一种机制，用来记录用户的一些信息
      //session 服务器端保存的一种数据结构，用来跟踪用户状态
      //session 默认存放在服务器的文件里，当然，文件，数据库，内存中都可以
      //session 的运行依赖session id。session id是存在cookie中的，浏览器禁用cookie的话，session也会失效。但可以通过其它方式，如在url中传递session_id

      //session token --》https://blog.csdn.net/mydistance/article/details/84545768 为什么使用token？session与token的区别
      //-session弊端
      //--服务器压力增大 每个用户通过认证后，都会将数据保存在服务器的内存中，用户量增大后..
      //--跨站请求伪造CSRF(cross-site request forgery) session是基于cookie进行用户识别的，cookie若被截获..
      //--扩展性不强 如果将来搭建多个服务器，session数据是保存在内存中的，用户第一次访问服务器1，
      //  当再次请求时可能访问的是服务器2，服务器2获取不到session信息，就判断用户没登录过

      //-token
      //--认证成功后，会对当前用户数据进行加密，生成一个加密字符串token，返还给客户端（服务器端并不进行保存）
      //--
      //--再次访问时，服务器对传来的token进行解密，解密完成后进行用户数据查询，查询成功，则通过认证，实现状态保持。
      //  就算有多台服务器，服务器也只是做解密和查询，不需要保留用户的认证信息或者会话信息。也就是不需要考虑在哪一台服务器登录了，为应用的扩展提供了便利
    </script>
  </body>
</html>
